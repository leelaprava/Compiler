

package cop5556fa17;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

public class Scanner {

	@SuppressWarnings("serial")
	public static class LexicalException extends Exception {

		int pos;

		public LexicalException(String message, int pos) {
			super(message);
			this.pos = pos;
		}

		public int getPos() { return pos; }

	}

	public static enum Kind {
		IDENTIFIER, INTEGER_LITERAL, BOOLEAN_LITERAL, STRING_LITERAL,
		KW_x/* x */, KW_X/* X */, KW_y/* y */, KW_Y/* Y */, KW_r/* r */, KW_R/* R */, KW_a/* a */,
		KW_A/* A */, KW_Z/* Z */, KW_DEF_X/* DEF_X */, KW_DEF_Y/* DEF_Y */, KW_SCREEN/* SCREEN */,
		KW_cart_x/* cart_x */, KW_cart_y/* cart_y */, KW_polar_a/* polar_a */, KW_polar_r/* polar_r */,
		KW_abs/* abs */, KW_sin/* sin */, KW_cos/* cos */, KW_atan/* atan */, KW_log/* log */,
		KW_image/* image */,  KW_int/* int */,
		KW_boolean/* boolean */, KW_url/* url */, KW_file/* file */, OP_ASSIGN/* = */, OP_GT/* > */, OP_LT/* < */,
		OP_EXCL/* ! */, OP_Q/* ? */, OP_COLON/* : */, OP_EQ/* == */, OP_NEQ/* != */, OP_GE/* >= */, OP_LE/* <= */,
		OP_AND/* & */, OP_OR/* | */, OP_PLUS/* + */, OP_MINUS/* - */, OP_TIMES/* * */, OP_DIV/* / */, OP_MOD/* % */,
		OP_POWER/* ** */, OP_AT/* @ */, OP_RARROW/* -> */, OP_LARROW/* <- */, LPAREN/* ( */, RPAREN/* ) */,
		LSQUARE/* [ */, RSQUARE/* ] */, SEMI/* ; */, COMMA/* , */, EOF;
	}

	/** Class to represent Tokens.
	 *
	 * This is defined as a (non-static) inner class
	 * which means that each Token instance is associated with a specific
	 * Scanner instance.  We use this when some token methods access the
	 * chars array in the associated Scanner.
	 *
	 *
	 * @author Beverly Sanders
	 *
	 */
	public class Token {
		public final Kind kind;
		public final int pos;
		public final int length;
		public final int line;
		public final int pos_in_line;

		public Token(Kind kind, int pos, int length, int line, int pos_in_line) {
			super();
			this.kind = kind;
			this.pos = pos;
			this.length = length;
			this.line = line;
			this.pos_in_line = pos_in_line;
		}

		public String getText() {
			if (kind == Kind.STRING_LITERAL) {
				return chars2String(chars, pos, length);
			}
			else return String.copyValueOf(chars, pos, length);
		}

		/**
		 * To get the text of a StringLiteral, we need to remove the
		 * enclosing " characters and convert escaped characters to
		 * the represented character.  For example the two characters \ t
		 * in the char array should be converted to a single tab character in
		 * the returned String
		 *
		 * @param chars
		 * @param pos
		 * @param length
		 * @return
		 */
		private String chars2String(char[] chars, int pos, int length) {
			StringBuilder sb = new StringBuilder();
			for (int i = pos + 1; i < pos + length - 1; ++i) {// omit initial and final "
				char ch = chars[i];
				if (ch == '\\') { // handle escape
					i++;
					ch = chars[i];
					switch (ch) {
					case 'b':
						sb.append('\b');
						break;
					case 't':
						sb.append('\t');
						break;
					case 'f':
						sb.append('\f');
						break;
					case 'r':
						sb.append('\r'); //for completeness, line termination chars not allowed in String literals
						break;
					case 'n':
						sb.append('\n'); //for completeness, line termination chars not allowed in String literals
						break;
					case '\"':
						sb.append('\"');
						break;
					case '\'':
						sb.append('\'');
						break;
					case '\\':
						sb.append('\\');
						break;
					default:
						assert false;
						break;
					}
				} else {
					sb.append(ch);
				}
			}
			return sb.toString();
		}

		/**
		 * precondition:  This Token is an INTEGER_LITERAL
		 *
		 * @returns the integer value represented by the token
		 */
		public int intVal() {
			assert kind == Kind.INTEGER_LITERAL;
			return Integer.valueOf(String.copyValueOf(chars, pos, length));
		}

		public String toString() {
			return "[" + kind + "," + String.copyValueOf(chars, pos, length)  + "," + pos + "," + length + "," + line + ","
					+ pos_in_line + "]";
		}

		/**
		 * Since we overrode equals, we need to override hashCode.
		 * https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-
		 *
		 * Both the equals and hashCode method were generated by eclipse
		 *
		 */
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((kind == null) ? 0 : kind.hashCode());
			result = prime * result + length;
			result = prime * result + line;
			result = prime * result + pos;
			result = prime * result + pos_in_line;
			return result;
		}

		/**
		 * Override equals method to return true if other object
		 * is the same class and all fields are equal.
		 *
		 * Overriding this creates an obligation to override hashCode.
		 *
		 * Both hashCode and equals were generated by eclipse.
		 *
		 */
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Token other = (Token) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (kind != other.kind)
				return false;
			if (length != other.length)
				return false;
			if (line != other.line)
				return false;
			if (pos != other.pos)
				return false;
			if (pos_in_line != other.pos_in_line)
				return false;
			return true;
		}

		/**
		 * used in equals to get the Scanner object this Token is
		 * associated with.
		 * @return
		 */
		private Scanner getOuterType() {
			return Scanner.this;
		}

	}

	/**
	 * Extra character added to the end of the input characters to simplify the
	 * Scanner.
	 */
	static final char EOFchar = 0;

	/**
	 * The list of tokens created by the scan method.
	 */
	final ArrayList<Token> tokens;

	/**
	 * An array of characters representing the input.  These are the characters
	 * from the input string plus and additional EOFchar at the end.
	 */
	final char[] chars;




	/**
	 * position of the next token to be returned by a call to nextToken
	 */
	private int nextTokenPos = 0;

	Scanner(String inputString) {
		int numChars = inputString.length();
		//System.out.println(numChars+"----");
		this.chars = Arrays.copyOf(inputString.toCharArray(), numChars + 1 ); // input string terminated with null char
		//System.out.println(chars.length+"+++");
		chars[numChars] = EOFchar;
		tokens = new ArrayList<Token>();
	}

	public static enum State {
		START,INT_LIT,NEWLINE,IDENTIFIER,ST_LIT,AFTER_EQ,AFTER_NOT,AFTER_MINUS,AFTER_GT,POWER,IS_DIV,
		AFTER_OR,AFTER_LT,AFTER_DIV,COMMENT_START,AFTER_MIN,ESCAPE;
	 }
	/**
	 * Method to scan the input and create a list of Tokens.
	 *
	 * If an error is encountered during scanning, throw a LexicalException.
	 *
	 * @return
	 * @throws LexicalException
	 */
	public Scanner scan() throws LexicalException {
		/* TODO  Replace this with a correct and complete implementation!!! */
		HashMap <String,Kind> map=new HashMap<String,Kind>();
		for (Kind kind : Kind.values() )
			{
				if(kind.toString().substring(0, 3).contentEquals("KW_"))
				{
					int len=kind.toString().length();
			        map.put(kind.toString().substring(3,len), kind);
				}
			}

		int pos = 0;
		int Startpos=0,StartposInLine=0;
		int line = 1;
		int posInLine = 1;
		boolean lit_flag=false;
		boolean quote_flag=false;
		State state=State.START;
		//System.out.println(chars);
		while(pos<chars.length){
			//System.out.println(chars[pos]+"-----"+pos);
			char ch=chars[pos];
			switch(state){
				case START :

					//switch(ch){
					    if(ch== ' ') posInLine++;
						else if(ch== ';'   ){tokens.add(new Token(Kind.SEMI,pos,1,line,posInLine)); posInLine++;}
						else if(ch== '\n' ) {line++;posInLine=1;}
						else if(ch== '\r' ) state=State.NEWLINE;
						else if(ch== '\t' ) posInLine++;
						else if(ch== '\f')  posInLine++;
						else if(ch== '"'){state=State.ST_LIT; quote_flag=true; Startpos=pos;StartposInLine=posInLine;}
						else if(ch== '=') state=State.AFTER_EQ;
						else if(ch== '>')state=State.AFTER_GT;
						else if(ch== '<')state=State.AFTER_LT;
						else if(ch== '-')state=State.AFTER_MIN;
						else if(ch=='!') state=State.AFTER_NOT;
						else if(ch=='?'){tokens.add(new Token(Kind.OP_Q,pos,1,line,posInLine)); posInLine++;}
						else if(ch== '&'){tokens.add(new Token(Kind.OP_AND,pos,1,line,posInLine)); posInLine++;}
						else if(ch=='@'){tokens.add(new Token(Kind.OP_AT,pos,1,line,posInLine)); posInLine++;}
						else if(ch== ':'){tokens.add(new Token(Kind.OP_COLON,pos,1,line,posInLine)); posInLine++;}
						else if(ch== '%'){tokens.add(new Token(Kind.OP_MOD,pos,1,line,posInLine)); posInLine++;}
						else if(ch== '|'){tokens.add(new Token(Kind.OP_OR,pos,1,line,posInLine)); posInLine++;}
						else if(ch== '('){tokens.add(new Token(Kind.LPAREN,pos,1,line,posInLine)); posInLine++;}
						else if(ch==')'){tokens.add(new Token(Kind.RPAREN,pos,1,line,posInLine)); posInLine++;}
						else if(ch== '['){tokens.add(new Token(Kind.LSQUARE,pos,1,line,posInLine)); posInLine++;}
						else if(ch== ']'){tokens.add(new Token(Kind.RSQUARE,pos,1,line,posInLine)); posInLine++;}
						else if(ch==','){tokens.add(new Token(Kind.COMMA,pos,1,line,posInLine)); posInLine++;}
						else if (ch=='*')state=State.POWER;
						else if (ch=='+'){tokens.add(new Token(Kind.OP_PLUS,pos,1,line,posInLine)); posInLine++;}
						else if( ch=='/'){state=State.IS_DIV;}
						//case '\0': throw new LexicalException("Unexpected termination",pos);
						//default :
						else if (Character.isDigit(ch))
							{
								if(ch=='0'){
									tokens.add(new Token(Kind.INTEGER_LITERAL,pos,1,line,posInLine));
									posInLine++;
								}
								else
								{state = State.INT_LIT;Startpos=pos;}
								}
						else if (((int)ch<91&&(int)ch>64)||((int)ch<123&&(int)ch>96)||ch=='_'||ch=='$') {                      //Character.isJavaIdentifierStart(ch)
								state = State.IDENTIFIER;Startpos=pos;
							}
						else if(pos!=chars.length-1){
							//System.out.println(ch+"-----"+pos);
							throw new LexicalException("Unable to process character",pos);
						}
						//	break;

				//}
					    break;
	        	case ESCAPE: if(ch=='b'|ch=='t'|ch=='n'|ch=='f'|ch=='r'|ch=='"'|ch=='\''|ch=='\\')
	        		{
	        		    //System.out.println("In escape");
	        			//posInLine++;
	        			state=State.ST_LIT;
//	        			if(ch=='"'){
//	        				lit_flag=true;
//	        			}
	        		}

	        	else{

	        		throw new LexicalException("Escape character has no follow up", pos);       // $$$
	        	}
	                          	break;
				case INT_LIT :
					if(!Character.isDigit(ch)){
						state=State.START;
						String num=String.copyValueOf(chars, Startpos, pos-Startpos);
						try
						{
							int x= Integer.parseInt(num);


						}catch(NumberFormatException e)
						{

							throw new LexicalException("number format exception", Startpos);
						}


						tokens.add(new Token(Kind.INTEGER_LITERAL,Startpos,pos-Startpos,line,posInLine));
						posInLine=posInLine+pos-Startpos;
						pos--;
					}
					break;
				case NEWLINE : if(ch!='\n'){pos--;}state=State.START; line++;posInLine=1;break;
				case IDENTIFIER :
					
					if(!(Character.isJavaIdentifierStart(ch)||Character.isDigit(ch)))
					{   
						state=State.START;
						if (map.containsKey(String.copyValueOf(chars, Startpos, pos-Startpos)))
							tokens.add(new Token(map.get(String.copyValueOf(chars, Startpos, pos-Startpos)),Startpos,pos-Startpos,line,posInLine));
					    else
					    	{
					    	    if(String.copyValueOf(chars, Startpos, pos-Startpos).toString().equals("true"))
					    	    	tokens.add(new Token(Kind.BOOLEAN_LITERAL,Startpos,pos-Startpos,line,posInLine));
					    	    else if(String.copyValueOf(chars, Startpos, pos-Startpos).toString().equals("false"))
					    	    	tokens.add(new Token(Kind.BOOLEAN_LITERAL,Startpos,pos-Startpos,line,posInLine));
					    	    else
					    	    	tokens.add(new Token(Kind.IDENTIFIER,Startpos,pos-Startpos,line,posInLine));
					    		}
						posInLine=posInLine+pos-Startpos;
						pos--;
					}
					break;
				case ST_LIT :
					//System.out.println("Startpos--"+Startpos+"--StartposInLine---"+StartposInLine+"----pos--"+pos+"--posInLine---"+posInLine);
					if(ch=='\n'||ch=='\r'){
						throw new LexicalException("No line breaks", pos);
					}
					if(ch=='"'){
					quote_flag=false;
					state=State.START;
					tokens.add(new Token(Kind.STRING_LITERAL,Startpos,pos-Startpos+1,line,StartposInLine));
				    posInLine=posInLine+pos-Startpos+1;
				   }
				    if(ch=='\\'){state=State.ESCAPE;}//posInLine++;
				break;
				case AFTER_EQ:
					if(ch=='='){
						tokens.add(new Token(Kind.OP_EQ,pos-1,2,line,posInLine));
						posInLine=posInLine+2;
					}else{
						tokens.add(new Token(Kind.OP_ASSIGN,pos-1,1,line,posInLine));

						posInLine++;
						pos--;
					}
					state=State.START;
					break;
				case AFTER_NOT:
					if(ch=='='){
						tokens.add(new Token(Kind.OP_NEQ,pos-1,2,line,posInLine));
						posInLine=posInLine+2;
					}else{
						tokens.add(new Token(Kind.OP_EXCL,pos-1,1,line,posInLine));

						posInLine++;
						pos--;
					}
					state=State.START;
					break;
				case AFTER_GT:
					if(ch=='='){
						tokens.add(new Token(Kind.OP_GE,pos-1,2,line,posInLine));
						posInLine=posInLine+2;
					}else{
						tokens.add(new Token(Kind.OP_GT,pos-1,1,line,posInLine));
						posInLine++;
						pos--;
					}
					state=State.START;
					break;
				case AFTER_LT:
					if(ch=='='){
						tokens.add(new Token(Kind.OP_LE,pos-1,2,line,posInLine));
						posInLine=posInLine+2;
					}
					else if(ch=='-'){
						tokens.add(new Token(Kind.OP_LARROW,pos-1,2,line,posInLine));
						posInLine=posInLine+2;
					}
					else{
						tokens.add(new Token(Kind.OP_LT,pos-1,1,line,posInLine));
						posInLine++;
						pos--;
					}
					state=State.START;
					break;
				case POWER:
					if(ch=='*'){
						tokens.add(new Token(Kind.OP_POWER,pos-1,2,line,posInLine));
						posInLine=posInLine+2;
					}else{
						tokens.add(new Token(Kind.OP_TIMES,pos-1,1,line,posInLine));
						posInLine++;
						pos--;
					}
					state=State.START;
					break;
				case AFTER_MIN:
					if(ch=='>'){
						tokens.add(new Token(Kind.OP_RARROW,pos-1,2,line,posInLine));
						posInLine=posInLine+2;
					}else{
						tokens.add(new Token(Kind.OP_MINUS,pos-1,1,line,posInLine));
						posInLine++;
						pos--;
					}
					state=State.START;
					break;
				case COMMENT_START:
	             // System.out.println("Entered comment--------");
					while(ch!='\n'&&ch!='\r'&&ch!=EOFchar){
						
						posInLine++;
						pos++;
						ch=chars[pos];
					}
					pos--;
					state=State.START;
					break;
				case IS_DIV:
					if(ch!='/'){
						pos--;
						tokens.add(new Token(Kind.OP_DIV,pos,1,line,posInLine));
						posInLine++;
						state=State.START;
					}
					else{
						state=State.COMMENT_START;
						posInLine=posInLine+2;
					}
					break;

			}
			pos++;
		}
		//line=1;
		//posInLine=1;
		if(quote_flag)
			throw new LexicalException("The String literal is not Closed", pos-1);//$$$
		tokens.add(new Token(Kind.EOF, pos-1, 0, line, posInLine));
		//System.out.println(tokens);
		return this;

	}



    /**
	 * Returns true if the internal interator has more Tokens
	 *
	 * @return
	 */
	public boolean hasTokens() {
		return nextTokenPos < tokens.size();
	}

	/**
	 * Returns the next Token and updates the internal iterator so that
	 * the next call to nextToken will return the next token in the list.
	 *
	 * It is the callers responsibility to ensure that there is another Token.
	 *
	 * Precondition:  hasTokens()
	 * @return
	 */
	public Token nextToken() {
		return tokens.get(nextTokenPos++);
	}

	/**
	 * Returns the next Token, but does not update the internal iterator.
	 * This means that the next call to nextToken or peek will return the
	 * same Token as returned by this methods.
	 *
	 * It is the callers responsibility to ensure that there is another Token.
	 *
	 * Precondition:  hasTokens()
	 *
	 * @return next Token.
	 */
	public Token peek() {
		return tokens.get(nextTokenPos);
	}


	/**
	 * Resets the internal iterator so that the next call to peek or nextToken
	 * will return the first Token.
	 */
	public void reset() {
		nextTokenPos = 0;
	}

	/**
	 * Returns a String representation of the list of Tokens
	 */
	public String toString() {
		StringBuffer sb = new StringBuffer();
		sb.append("Tokens:\n");
		for (int i = 0; i < tokens.size(); i++) {
			sb.append(tokens.get(i)).append('\n');
		}
		return sb.toString();
	}

}
